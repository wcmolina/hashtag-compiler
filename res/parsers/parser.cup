package com.compiler.hashtag;

import com.compiler.ast.Data;
import com.compiler.ast.Node;
import com.compiler.ast.FunctionType;
import java_cup.runtime.Symbol;

parser code {:
    public Node root = null;
    public int errors = 0;
    public int fatal = 0;

    public void report_error(String message, Object info){
        StringBuilder m = new StringBuilder("");
        if(info instanceof java_cup.runtime.Symbol){
            m.append("Error: ");
            m.append(info);
            m.append(": " + message);
        } else {
            if (info instanceof String) {
                errors++;
                m.append("    "+ errors + "==> " + info + " "+ message+"\n");
            }
        }
        Editor.console.setText(Editor.console.getText() + m.toString() + "\n");
    }

    public void report_fatal_error(String message, Object info){
        fatal++;
        report_error(message, info);
    }
:}

//-----------------------------------------Terminals and non terminals---------------------------------------

terminal SUMA,MENOS,DIV,MULT,MAYOR,MENOR,MAYORIGUAL,MENORIGUAL,NOT,DIFERENTE,IGUAL,ASIGNACION;
terminal PARDER,PARIZQ,MOD,COMA,PUNTOCOMA,MAINBEGIN,DOSPUNTOS;
terminal AND,OR,FOR,IF,ELSE,WHILE,BEGIN,END,SWITCH,CASE,DO,FUNCTION,BREAK,RETURN,PRINT;
terminal INT,DOUBLE,CHAR,STRING,BOOLEAN,READSTRING,READCHAR,READINT,READDOUBLE,OTHER,VOID;

terminal Integer   NUMERO;
terminal Double    REAL;
terminal Character CARACTER;
terminal String    CADENA,IDENTIFICADOR;
terminal Boolean   FALSE,TRUE;

non terminal Node Main,BodyList,BodyPart,Type,Asignacion,Value,Program,FunctionList,FunctionPart,Statements;
non terminal Node Instruccion,Llamado,ExprComparacion,LogicalOperator,RelationalOper,ExprIncDec,Incremento,Decremento,BooleanExprList,BooleanExprPart;
non terminal Node Block,Loops,Conditional,ForStmt,WhileStmt,IfStmt,SwitchStmt,ForExpr,Break,CaseExpr,Case,Other;
non terminal Node Expression,ArithmeticExpr,Factor,Term,Contenido,PrintParam,Return;
non terminal Node Print,FunctionCall,Parametros,Param,ReturnExpr,Functions,Lectura,AddOrSubstract,MultiplyOrDivide;
non terminal Node VarDeclare,VarInit,VarDeclarationList,Identifier,Literals,StringLiterals,NumLiterals,BooleanLiterals;

precedence left  SUMA,MENOS;
precedence left  MULT,DIV,MOD;
precedence left  PARIZQ;

//--------------------------------------BNF Grammar------------------------------------------

start with Program;

Program                     ::= BEGIN Functions:f Main:mn END
                                {:
                                    RESULT = new Node("PROG", f, mn);
                                    parser.root = RESULT;
                                :}
                                |
                                BEGIN Main:mn END
                                {:
                                    RESULT = new Node("PROG", mn);
                                    parser.root = RESULT;
                                :}
                                |
                                error {: parser.report_error("syntax. Missing token 'begin'.","WRONG"); :} Main END;

Functions                   ::= FunctionList:fl
                                {: RESULT = new Node("FUNCTIONS",fl); :};

Main                        ::= MAINBEGIN Statements:st
                                {: RESULT = new Node("MAIN",st); :}
                                |
                                error {: parser.report_error("token 'mainbegin'.","MISSING"); :} Statements;

Statements                  ::= DO BodyList:bdl END
                                {: RESULT = bdl; :}
                                |
                                DO END
                                {: RESULT = new Node("null"); :}
                                |
                                error {: parser.report_error("block declaration syntax. Unmatched 'do' 'end' tokens.","WRONG"); :} BodyList END;

BodyList                    ::= BodyPart:bp BodyList:bdl
                                {: RESULT = bdl.add(bp); :}
                                |
                                BodyPart:bp
                                {: RESULT = new Node("body", bp); :};

BodyPart                    ::= Block:bq
                                {: RESULT = bq; :}
                                |
                                Instruccion:ins PUNTOCOMA
                                {: RESULT = ins; :}
                                |
                                Asignacion:asig PUNTOCOMA
                                {: RESULT = asig; :}
                                |
                                ReturnExpr:ret PUNTOCOMA
                                {: RESULT = ret; :}
                                |
                                Break:bk PUNTOCOMA
                                {: RESULT = bk; :}
                                |
                                CaseExpr:cs
                                {: RESULT = cs; :}
                                |
                                error {: parser.report_error("start of expression.","ILLEGAL"); :} BodyPart;

Instruccion                 ::= VarDeclare:vd
                                {: RESULT = vd; :}
                                |
                                VarInit:vi
                                {: RESULT = vi; :}
                                |
                                Llamado:l
                                {: RESULT = l; :}
                                |
                                error {: parser.report_error("variable initialization, declaration or function call","WRONG"); :} PUNTOCOMA;

Lectura                     ::= READINT PARIZQ PARDER
                                {: RESULT = new Node("READINT"); :}
                                |
                                READDOUBLE PARIZQ PARDER
                                {: RESULT = new Node("READDOUBLE"); :}
                                |
                                READSTRING PARIZQ PARDER
                                {: RESULT = new Node("READSTRING"); :}
                                |
                                READCHAR PARIZQ PARDER
                                {: RESULT = new Node("READCHAR"); :};

Break                       ::= BREAK
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"BREAK");
                                :};

CaseExpr                    ::= Case:cs Value:val DOSPUNTOS Statements:st
                                {: RESULT = cs.add(new Node("case_arg",val),st); :}
                                |
                                Other:ot DOSPUNTOS Statements:st
                                {: RESULT = ot.add(st); :}
                                |
                                CASE error {: parser.report_error("'CASE' syntax.","WRONG"); :} Statements
                                |
                                OTHER error {: parser.report_error("'OTHER' syntax.","WRONG"); :} Statements;

Case                        ::= CASE
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"CASE");
                                :};

Other                       ::= OTHER
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"OTHER");
                                :};

VarDeclare                  ::= VarDeclarationList:vdl
                                {:
                                    RESULT = vdl;
                                :};

VarDeclarationList          ::= VarDeclarationList:vdl COMA Identifier:iden
                                {:
                                    iden.getData().setType(vdl.getData().getType());
                                    RESULT = vdl.add(iden);
                                :}
                                |
                                Type:tp Identifier:iden
                                {:
                                    iden.getData().setType(tp.label); //habria que hacer clase Tipo propia?
                                    RESULT = new Node("declare", iden);
                                    RESULT.getData().setType(tp.label); //temporal solution so that every child of "declare" updates their type
                                :};

Identifier                  ::= IDENTIFICADOR:id
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "IDENTIFIER", null, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, id);
                                :};

VarInit                     ::= VarDeclare:vd ASIGNACION Value:av
                                {:
                                    for (Node declared: vd.getChildren()) {
                                        declared.getData().setValue(av.getData().getValue());
                                    }
                                    RESULT = new Node("init",vd,av);
                                :}
                                |
                                VarDeclare:vd ASIGNACION Lectura:lec
                                {: RESULT = new Node("init",vd,lec); :};

Value                       ::= Expression:eb
                                {: RESULT = eb; :}
                                |
                                FunctionCall:fc
                                {: RESULT = fc; :};

Asignacion                  ::= Identifier:iden ASIGNACION Value:val
                                {: RESULT = new Node("assign",iden,val); :}
                                |
                                Identifier:iden ASIGNACION Lectura:lec
                                {: RESULT = new Node("assign",iden,lec); :}
                                |
                                ExprIncDec:update
                                {: RESULT = update; :};

Type                        ::= INT
                                {: RESULT = new Node("int"); :}
                                |
                                DOUBLE
                                {: RESULT = new Node("double"); :}
                                |
                                CHAR
                                {: RESULT = new Node("char"); :}
                                |
                                BOOLEAN
                                {: RESULT = new Node("boolean"); :}
                                |
                                STRING
                                {: RESULT = new Node("string"); :};

//--------------------------Method calls-------------------------------

Llamado                     ::= Print:pr
                                {: RESULT = pr; :}
                                |
                                FunctionCall:lm
                                {: RESULT = lm; :};

FunctionCall                ::= Identifier:id PARIZQ Contenido:cont PARDER
                                {: RESULT = new Node("function_call",id,cont); :}
                                |
                                Identifier:id PARIZQ PARDER
                                {: RESULT = new Node("function_call", id, new Node("parameters",new Node("null"))); :};

Contenido                   ::= Value:val COMA Contenido:cont
                                {: RESULT = cont.add(val); :}
                                |
                                Value:val
                                {: RESULT = new Node("parameters",val); :};

//--------------------------Parameters-------------------------------

Print                       ::= PRINT PARIZQ PrintParam:pp PARDER
                                {: RESULT = new Node("PRINT", pp); :};

PrintParam                  ::= Value:val
                                {: RESULT = val; :}
                                |
                                {: RESULT = new Node("null"); :};

//--------------------------Functions-------------------------------

FunctionList                ::= FunctionPart:fp FunctionList:fl
                                {: RESULT = fl.add(fp); :}
                                |
                                FunctionPart:fp
                                {: RESULT = new Node("body",fp); :};

FunctionPart                ::= FUNCTION VOID Identifier:id PARIZQ Parametros:param PARDER Statements:st
                                {:
                                    StringBuilder domain = new StringBuilder("");
                                    if (param.getChildren().size()>0) {
                                        for (Node iden : param.getChildren()){
                                            domain.append(iden.getData().getType().concat("x"));
                                        }
                                        domain.deleteCharAt(domain.length()-1);
                                    }

                                    FunctionType function = new FunctionType(id,domain.toString(),"void");
                                    Data data = id.getData();
                                    data.setValue(function);
                                    RESULT = new Node(data, id.label, param, st);
                                :}
                                |
                                FUNCTION Type:tp Identifier:id PARIZQ Parametros:param PARDER Statements:st
                                {:
                                    StringBuilder domain = new StringBuilder("");
                                    if (param.getChildren().size()>0) {
                                        for (Node iden : param.getChildren()){
                                            domain.append(iden.getData().getType().concat("x"));
                                        }
                                        domain.deleteCharAt(domain.length()-1);
                                    }

                                    FunctionType function = new FunctionType(id, domain.toString(), tp.label);
                                    Data data = id.getData();
                                    data.setValue(function);
                                    RESULT = new Node(data, id.label, param, st);
                                :}
                                |
                                FUNCTION error {:
                                            parser.report_error("function declaration. Usage example: function <type> <id> () do ... end","WRONG");
                                        :} Statements;

Parametros                  ::= Parametros:params COMA Param:param
                                {: RESULT = params.add(param); :}
                                |
                                Param:param
                                {: RESULT = new Node("parameters",param); :}
                                |
                                {: RESULT = new Node("parameters",new Node("null")); :};

Param                       ::= Type:tp Identifier:id
                                {:
                                    RESULT = id;
                                    if (tp.label.equalsIgnoreCase("int")) {
                                        RESULT.getData().setValue(0);
                                    } else if (tp.label.equalsIgnoreCase("double")) {
                                        RESULT.getData().setValue(0.0);
                                    } else if (tp.label.equalsIgnoreCase("boolean")) {
                                        RESULT.getData().setValue(false);
                                    } else if (tp.label.equalsIgnoreCase("string")) {
                                        RESULT.getData().setValue("");
                                    } else if (tp.label.equalsIgnoreCase("char")) {
                                        RESULT.getData().setValue(' ');
                                    }
                                :};

ReturnExpr                  ::= Return:ret Value:val
                                {: RESULT = ret.add(val); :};

Return                      ::= RETURN
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol), "RETURN");
                                :};

//--------------------------Blocks (if, switch, while, for)-------------------------------

Block                       ::= Loops:lp
                                {: RESULT = lp; :}
                                |
                                Conditional:cond
                                {: RESULT = cond; :};

Loops                       ::= ForStmt:flp
                                {: RESULT = flp; :}
                                |
                                WhileStmt:wlp
                                {: RESULT = wlp; :};

Conditional                 ::= IfStmt:ic
                                {: RESULT = ic; :}
                                |
                                SwitchStmt:swc
                                {: RESULT = swc; :};

ForStmt                     ::= FOR PARIZQ ForExpr:expr PARDER Statements:st
                                {:
                                    RESULT = new Node("FOR", expr, st);
                                    RESULT.getData().setType("for_statement");
                                :}
                                |
                                FOR error {: parser.report_error("FOR statement declaration","WRONG"); :} Statements;

ForExpr                     ::= VarInit:init PUNTOCOMA Expression:expr PUNTOCOMA ExprIncDec:update
                                {: RESULT = new Node("structure",init,expr,update); :};

WhileStmt                   ::= WHILE PARIZQ Expression:expr PARDER Statements:st
                                {:
                                    RESULT = new Node("WHILE",new Node("conditions",expr), st);
                                    RESULT.getData().setType("while_statement");
                                :}
                                |
                                WHILE PARIZQ PARDER error {: parser.report_error("WHILE statement declaration, missing boolean expression.","WRONG"); :} Statements
                                |
                                WHILE error {: parser.report_error("WHILE statement declaration. Usage example:\n\n\twhile (<boolean expression>) do \n\t\t...\n\tend","WRONG"); :} Statements;

IfStmt                      ::= IF PARIZQ Expression:expr PARDER Statements:st
                                {:
                                    RESULT = new Node("IF",new Node("conditions",expr), st);
                                    RESULT.getData().setType("if_statement");
                                :}
                                |
                                IF PARIZQ Expression:expr PARDER Statements:st1 ELSE Statements:st2
                                {: RESULT = new Node("IF",new Node("conditions",expr),st1,new Node("ELSE",st2)); :}
                                |
                                IF error {: parser.report_error("IF statement declaration. Usage example:\n\n\tif (<boolean expression>) do \n\t\t...\n\tend", "WRONG"); :} Statements;

SwitchStmt                  ::= SWITCH PARIZQ Expression:expr PARDER Statements:st
                                {:
                                    RESULT = new Node("SWITCH", new Node("switch_arg",expr), st);
                                    RESULT.getData().setType("switch_statement");
                                :}
                                |
                                SWITCH error {:parser.report_error("SWITCH statement declaration.","WRONG"); :} Statements;


//--------------------------Boolean expressions-------------------------------

Expression                  ::= BooleanExprList:bel
                                {: RESULT = bel; :};

BooleanExprList             ::= BooleanExprList:list LogicalOperator:lop BooleanExprPart:part
                                {:
                                    RESULT = new Node(lop.label,list,part);
                                    RESULT.getData().setType("boolean");
                                :}
                                |
                                BooleanExprPart:part
                                {: RESULT = part; :};

BooleanExprPart             ::= ExprComparacion:ec
                                {: RESULT = ec; :};

ExprComparacion             ::= ArithmeticExpr:ae1 RelationalOper:oprel ArithmeticExpr:ae2
                                {:
                                    RESULT = oprel.add(ae1,ae2);
                                    RESULT.getData().setType("boolean");
                                :}
                                |
                                NOT ExprComparacion:exprc
                                {: RESULT = new Node("negation", exprc); :}
                                |
                                ArithmeticExpr:ae
                                {: RESULT = ae; :};

RelationalOper              ::= MAYOR
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),">");
                                :}
                                |
                                MENOR
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"<");
                                :}
                                |
                                MAYORIGUAL
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),">=");
                                :}
                                |
                                MENORIGUAL
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"<=");
                                :}
                                |
                                IGUAL
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"==");
                                :}
                                |
                                DIFERENTE
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"!=");
                                :};

LogicalOperator             ::= AND
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"AND");
                                :}
                                |
                                OR
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol),"OR");
                                :};


//--------------------------Arithmetic expression-------------------------------

ArithmeticExpr              ::= ArithmeticExpr:ea AddOrSubstract:aos Factor:fct
                                {: RESULT = aos.add(ea,fct); :}
                                |
                                Factor:fct
                                {: RESULT = fct; :};

Factor                      ::= Factor:fct MultiplyOrDivide:mdm Term:trm
                                {: RESULT = mdm.add(fct,trm); :}
                                |
                                Term:trm
                                {: RESULT = trm; :};

Term                        ::= PARIZQ Expression:expr PARDER
                                {: RESULT = expr; :}
                                |
                                Literals:lit
                                {: RESULT = lit; :};

AddOrSubstract              ::= SUMA
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol), "+");
                                :}
                                |
                                MENOS
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol), "-");
                                :};

MultiplyOrDivide            ::= MULT
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol), "*");
                                :}
                                |
                                DIV
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol), "/");
                                :}
                                |
                                MOD
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();
                                    RESULT = new Node(new Data(symbol), "%");
                                :};

Literals                    ::= NumLiterals:nl
                                {: RESULT = nl; :}
                                |
                                StringLiterals:sl
                                {: RESULT = sl; :}
                                |
                                BooleanLiterals:bl
                                {: RESULT = bl; :}
                                |
                                Identifier:id
                                {: RESULT = id; :};

NumLiterals                 ::= NUMERO:num
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "NUMBER", num, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, Integer.toString(num));
                                :}
                                |
                                REAL:real
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "REAL", real, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, Double.toString(real));
                                :}
                                |
                                MENOS NUMERO:num
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "NUMBER", num*-1, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, Integer.toString(num*-1));
                                :}
                                |
                                MENOS REAL:real
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "REAL", real*-1, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, Double.toString(real*-1));
                                :};

StringLiterals              ::= CADENA:str
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "STRING", str, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat,"\""+str+"\"");
                                :}
                                |
                                CARACTER:ch
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "CHARACTER", ch, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, ("'").concat(Character.toString(ch)).concat("'"));
                                :};

BooleanLiterals             ::= TRUE
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "TRUE", new Boolean(true), symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, "true");
                                :}
                                |
                                FALSE
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "FALSE", new Boolean(false), symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, "false");
                                :};

//------------------------------- Increment/decrement expressions -------------------------------

ExprIncDec                  ::= Identifier:id Incremento
                                {: RESULT = new Node("increase", id); :}
                                |
                                Identifier:id Decremento
                                {: RESULT = new Node("decrease", id); :};

Incremento                  ::= SUMA SUMA;

Decremento                  ::= MENOS MENOS;