package com.compiler.hashtag;

import com.compiler.ast.Data;
import com.compiler.ast.Node;

parser code {:
    public Node root = null;
    public int errors = 0;
    public int fatal = 0;
    //Lexer lexer = (Lexer) this.getScanner();

    public JavaSymbol getCurrentSymbol() {
        return (JavaSymbol) this.cur_token;
    }

    public void report_error(String message, Object info){
        StringBuilder m = new StringBuilder("");
        if(info instanceof java_cup.runtime.Symbol){
            m.append("Error: ");
            m.append(info);
            m.append(" : " + message);
        } else {
            if (info instanceof String) {
                errors++;
                m.append("    "+ errors + "==> " + info + " "+ message+"\n");
            }
        }
        Editor.console.setText(Editor.console.getText() + m.toString() + "\n");
    }

    public void report_fatal_error(String message, Object info){
        fatal++;
        report_error(message, info);
    }
:}

//-----------------------------------------Terminals and non terminals---------------------------------------

terminal SUMA,MENOS,DIV,MULT,MAYOR,MENOR,MAYORIGUAL,MENORIGUAL,NOT,DIFERENTE,IGUAL,ASIGNACION;
terminal PARDER,PARIZQ,MOD,COMA,PUNTOCOMA,MAINBEGIN,DOSPUNTOS;
terminal AND,OR,FOR,IF,ELSE,WHILE,BEGIN,END,SWITCH,CASE,DO,FUNCTION,BREAK,RETURN,PRINT;
terminal INT,DOUBLE,CHAR,STRING,BOOLEAN,READSTRING,READCHAR,READINT,READDOUBLE,OTHER,VOID;

terminal Integer   NUMERO;
terminal Double    REAL;
terminal Character CARACTER;
terminal String    CADENA,IDENTIFICADOR;
terminal Boolean   FALSE,TRUE;


non terminal Node Main,BodyList,BodyPart,Type,Asignacion,Value,Program,FunctionList,FunctionPart,Statements;
non terminal Node Instruccion,Llamado,ExprComparacion,LogicalOperator,RelationalOper,ExprIncDec,Incremento,Decremento,BooleanExprList,BooleanExprPart;
non terminal Node Block,Loops,Conditional,ForStmt,WhileStmt,IfStmt,SwitchStmt,ForExpr,Switch,SwitchExprList,SwitchExprPart;
non terminal Node Expression,ArithmeticExpr,Factor,Term,Contenido,PrintParam;
non terminal Node Print,LlamadoMetodos,Parametros,Param,Return,Functions,Lectura;
non terminal Node VarDeclare,VarInit,VarDeclarationList,Identifier,Literals,StringLiterals,NumLiterals,BooleanLiterals;


precedence left  SUMA,MENOS;
precedence left  MULT,DIV,MOD;
precedence left  PARIZQ;

//--------------------------------------BNF Grammar------------------------------------------

start with Program;

Program                     ::= BEGIN Functions:f Main:mn END
                                {:
                                    RESULT = new Node("PROG", f, mn);
                                    parser.root = RESULT;
                                :}
                                |
                                BEGIN Main:mn END
                                {:
                                    RESULT = new Node("PROG", mn);
                                    parser.root = RESULT;
                                :}
                                |
                                error {: parser.report_error("syntax. Missing token 'begin'.","WRONG"); :} Main END
                                ;

Functions                   ::= FunctionList:fl
                                {: RESULT = new Node("FUNCTIONS",fl); :}
                                ;

Main                        ::= MAINBEGIN Statements:st
                                {: RESULT = new Node("MAIN",st); :}
                                |
                                error {: parser.report_error("token 'mainbegin'.","MISSING"); :} Statements;

Statements                  ::= DO BodyList:bdl END
                                {: RESULT = bdl; :}
                                |
                                DO END
                                {: RESULT = new Node("..."); :}
                                |
                                error {: parser.report_error("block declaration syntax. Unmatched 'do' 'end' tokens.","WRONG"); :} BodyList END
                                ;

BodyList                    ::= BodyPart:bp BodyList:bdl
                                {: RESULT = bdl.add(bp); :}
                                |
                                BodyPart:bp
                                {: RESULT = new Node("body", bp); :}
                                ;

BodyPart                    ::= Instruccion:ins PUNTOCOMA
                                {: RESULT = ins; :}
                                |
                                Block:bq
                                {: RESULT = bq; :}
                                |
                                Asignacion:asig PUNTOCOMA
                                {: RESULT = asig; :}
                                |
                                Return:ret PUNTOCOMA
                                {: RESULT = ret; :}
                                |
                                error {: parser.report_error("start of expression.","ILLEGAL"); :} BodyPart
                                ;


Instruccion                 ::= VarDeclare:vd
                                {: RESULT = vd; :}
                                |
                                VarInit:vi
                                {: RESULT = vi; :}
                                |
                                Llamado:l
                                {: RESULT = l; :}
                                |
                                error {: parser.report_error("variable initialization, declaration or function call","WRONG"); :} PUNTOCOMA
                                ;

Lectura                     ::= READINT PARIZQ PARDER
                                {: RESULT = new Node("READINT"); :}
                                |
                                READDOUBLE PARIZQ PARDER
                                {: RESULT = new Node("READDOUBLE"); :}
                                |
                                READSTRING PARIZQ PARDER
                                {: RESULT = new Node("READSTRING"); :}
                                |
                                READCHAR PARIZQ PARDER
                                {: RESULT = new Node("READCHAR"); :}
                                ;

                /*
--------------------------------------------------------------------------------
                S-Atribuida ejemplo (como deber?a de ser):
                    V -> L
                    T -> int | double | char | string | boolean
                    L -> L,P
                    L -> TP
                    P -> id

                    donde:
                    V = VarDeclare
                    L = VarDeclarationList
                    P = Identifier
                    T = Type

                    Identifier not necessary anymore?
--------------------------------------------------------------------------------
                */

VarDeclare                  ::= VarDeclarationList:vdl
                                {:
                                    RESULT = vdl;
                                :}
                                ;

VarDeclarationList          ::= VarDeclarationList:vdl COMA Identifier:iden
                                {:
                                    iden.getData().setType(vdl.getData().getType());
                                    RESULT = vdl.add(iden);
                                :}
                                |
                                Type:tp Identifier:iden
                                {:
                                    iden.getData().setType(tp.label); //habria que hacer clase Tipo propia?
                                    RESULT = new Node("declare", iden);
                                    RESULT.getData().setType(tp.label); //temporal solution so that every child of "declare" updates their type
                                :}
                                ;

Identifier                  ::= IDENTIFICADOR:id
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "IDENTIFIER", null, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, id);
                                :}
                                ;

VarInit                     ::= VarDeclare:vd ASIGNACION Value:av
                                {:
                                    for (Node declared: vd.getChildren()) {
                                        declared.getData().setValue(av.getData().getValue());
                                    }
                                    RESULT = new Node("init",vd,av);
                                :}
                                |
                                VarDeclare:vd ASIGNACION Lectura:lec
                                {: RESULT = new Node("init",vd,lec); :}
                                ;

Value                       ::= Expression:eb
                                {: RESULT = eb; :}
                                ;

Asignacion                  ::= Identifier:iden ASIGNACION Value:val
                                {: RESULT = new Node("assign",iden,val); :}
                                |
                                Identifier:iden ASIGNACION Lectura:lec
                                {: RESULT = new Node("assign",iden,lec); :}
                                |
                                ExprIncDec:update
                                {: RESULT = update; :}
                                ;

Type                        ::= INT
                                {: RESULT = new Node("int"); :}
                                |
                                DOUBLE
                                {: RESULT = new Node("double"); :}
                                |
                                CHAR
                                {: RESULT = new Node("char"); :}
                                |
                                BOOLEAN
                                {: RESULT = new Node("boolean"); :}
                                |
                                STRING
                                {: RESULT = new Node("string"); :}
                                ;

//--------------------------Method calls-------------------------------

Llamado                     ::= Print:pr
                                {: RESULT = pr; :}
                                |
                                LlamadoMetodos:lm
                                {: RESULT = lm; :}
                                ;

LlamadoMetodos              ::= Identifier:id PARIZQ Contenido:cont PARDER
                                {: RESULT = new Node("function_call",id,cont); :}
                                |
                                Identifier:id PARIZQ PARDER
                                {: RESULT = new Node("function_call", id, new Node("params",new Node("?"))); :}
                                ;

Contenido                   ::= Value:val COMA Contenido:cont
                                {: RESULT = cont.add(val); :}
                                |
                                Value:val
                                {: RESULT = new Node("params",val); :};

//--------------------------Parameters-------------------------------

Parametros                  ::= Parametros:params COMA Param:param
                                {: RESULT = params.add(param); :}
                                |
                                Param:param
                                {: RESULT = new Node("parameters",param); :}
                                |
                                {: RESULT = new Node("..."); :}
                                ;

Param                       ::= Type:tp Identifier:id
                                {:
                                    RESULT = id;
                                    RESULT.getData().setType(tp.label);
                                :}
                                ;

Print                       ::= PRINT PARIZQ PrintParam:pp PARDER
                                {: RESULT = new Node("PRINT", pp); :};

PrintParam                  ::= Value:val
                                {: RESULT = val; :}
                                |
                                LlamadoMetodos:lm
                                {: RESULT = lm; :}
                                |
                                {: RESULT = new Node("..."); :}
                                ;

//--------------------------Functions-------------------------------

FunctionList                ::= FunctionPart:fp FunctionList:fl
                                {: RESULT = fl.add(fp); :}
                                |
                                FunctionPart:fp
                                {: RESULT = new Node("body",fp); :};

FunctionPart                ::= FUNCTION VOID IDENTIFICADOR:id PARIZQ Parametros:param PARDER Statements:st
                                {: RESULT = new Node(id, param, st); :}
                                |
                                FUNCTION Type IDENTIFICADOR:id PARIZQ Parametros:param PARDER Statements:st
                                {: RESULT = new Node(id, param, st); :}
                                |
                                FUNCTION error {:
                                            parser.report_error("function declaration. Usage example: function <type> <id> () do ... end","WRONG");
                                        :} Statements
                                ;

Return                      ::= RETURN LlamadoMetodos:lm
                                {: RESULT = new Node("RETURN",lm); :}
                                |
                                RETURN Value:av
                                {: RESULT = new Node("RETURN", av); :}
                                ;

//--------------------------Blocks (if, switch, while, for)-------------------------------

Block                       ::= Loops:lp
                                {: RESULT = lp; :}
                                |
                                Conditional:cond
                                {: RESULT = cond; :}
                                ;

Loops                       ::= ForStmt:flp
                                {: RESULT = flp; :}
                                |
                                WhileStmt:wlp
                                {: RESULT = wlp; :}
                                ;

Conditional                 ::= IfStmt:ic
                                {: RESULT = ic; :}
                                |
                                SwitchStmt:swc
                                {: RESULT = swc; :};

ForStmt                     ::= FOR PARIZQ ForExpr:expr PARDER Statements:st
                                {: RESULT = new Node("FOR", expr, st); :}
                                |
                                FOR error {: parser.report_error("FOR statement declaration","WRONG"); :} Statements;

ForExpr                     ::= VarInit:init PUNTOCOMA Expression:expr PUNTOCOMA ExprIncDec:update
                                {: RESULT = new Node("structure",init,expr,update); :};

WhileStmt                   ::= WHILE PARIZQ Expression:expr PARDER Statements:st
                                {: RESULT = new Node("WHILE",new Node("conditions",expr), st); :}
                                |
                                WHILE PARIZQ PARDER error {: parser.report_error("WHILE statement declaration, missing boolean expression.","WRONG"); :} Statements
                                |
                                WHILE error {: parser.report_error("WHILE statement declaration. Usage example:\n\n\twhile (<boolean expression>) do \n\t\t...\n\tend","WRONG"); :} Statements
                                ;

IfStmt                      ::= IF PARIZQ Expression:expr PARDER Statements:st
                                {: RESULT = new Node("IF",new Node("conditions",expr), st); :}
                                |
                                IF PARIZQ Expression:expr PARDER Statements:st1 ELSE Statements:st2
                                {: RESULT = new Node("IF",new Node("conditions",expr),st1,new Node("ELSE",st2)); :}
                                |
                                IF error {: parser.report_error("IF statement declaration. Usage example:\n\n\tif (<boolean expression>) do \n\t\t...\n\tend", "WRONG"); :} Statements;

SwitchStmt                  ::= SWITCH PARIZQ Identifier:id PARDER DO SwitchExprList:exprl END
                                {: RESULT = new Node("SWITCH", id, exprl); :}
                                |
                                SWITCH PARIZQ Switch:sw PARDER DO SwitchExprList:exprl END
                                {: RESULT = new Node("SWITCH", sw, exprl); :}
                                |
                                SWITCH error {:parser.report_error("SWITCH statement declaration.","WRONG"); :} SwitchExprList
                                ;

SwitchExprList              ::= SwitchExprPart:exprp SwitchExprList:exprl
                                {: RESULT = exprl.add(exprp); :}
                                |
                                SwitchExprPart:exprp
                                {: RESULT = new Node("body",exprp); :};

SwitchExprPart              ::= CASE Switch:sw DOSPUNTOS Statements:st BREAK PUNTOCOMA
                                {: RESULT = new Node("CASE", sw, st); :}
                                |
                                OTHER DOSPUNTOS Statements:st BREAK PUNTOCOMA
                                {: RESULT = new Node("OTHER", st); :}
                                |
                                CASE error {:parser.report_error("CASE syntax in SWITCH statement.","WRONG");:} Statements;

Switch                      ::= NUMERO:n
                                {: RESULT = new Node(Integer.toString(n)); :}
                                |
                                CARACTER:c
                                {: RESULT = new Node(Character.toString(c)); :};


//--------------------------Boolean expressions-------------------------------

Expression                  ::= BooleanExprList:bel
                                {: RESULT = bel; :}
                                ;

BooleanExprList             ::= BooleanExprList:list LogicalOperator:lop BooleanExprPart:part
                                {: RESULT = new Node(lop.label,list,part); :}
                                |
                                BooleanExprPart:part
                                {: RESULT = part; :}
                                ;

BooleanExprPart             ::= ExprComparacion:ec
                                {: RESULT = ec; :}
                                ;

ExprComparacion             ::= ArithmeticExpr:ae1 RelationalOper:oprel ArithmeticExpr:ae2
                                {: RESULT = new Node(oprel.label, ae1, ae2); :}
                                |
                                NOT ExprComparacion:exprc
                                {: RESULT = new Node("negation", exprc); :}
                                |
                                ArithmeticExpr:ae
                                {: RESULT = ae; :}
                                ;

RelationalOper              ::= MAYOR
                                {: RESULT = new Node(">"); :}
                                |
                                MENOR
                                {: RESULT = new Node("<"); :}
                                |
                                MAYORIGUAL
                                {: RESULT = new Node(">="); :}
                                |
                                MENORIGUAL
                                {: RESULT = new Node("<="); :}
                                |
                                IGUAL
                                {: RESULT = new Node("=="); :}
                                |
                                DIFERENTE
                                {: RESULT = new Node("!="); :}
                                ;

LogicalOperator             ::= AND
                                {: RESULT = new Node("AND"); :}
                                |
                                OR
                                {: RESULT = new Node("OR"); :}
                                ;


//--------------------------Arithmetic expression-------------------------------

ArithmeticExpr              ::= ArithmeticExpr:ea SUMA Factor:fct
                                {: RESULT = new Node("+",ea,fct); :}
                                |
                                ArithmeticExpr:ea MENOS Factor:fct
                                {: RESULT = new Node("-",ea,fct); :}
                                |
                                Factor:fct
                                {: RESULT = fct; :}
                                ;

Factor                      ::= Factor:fct MULT Term:trm
                                {: RESULT = new Node("*",fct,trm); :}
                                |
                                Factor:fct DIV Term:trm
                                {: RESULT = new Node("/",fct,trm); :}
                                |
                                Factor:fct MOD Term:trm
                                {: RESULT = new Node("%",fct,trm); :}
                                |
                                Term:trm
                                {: RESULT = trm; :}
                                ;

Term                        ::= PARIZQ Expression:expr PARDER
                                {: RESULT = expr; :}
                                |
                                Literals:lit
                                {: RESULT = lit; :}
                                ;

Literals                    ::= NumLiterals:nl
                                {: RESULT = nl; :}
                                |
                                StringLiterals:sl
                                {: RESULT = sl; :}
                                |
                                BooleanLiterals:bl
                                {: RESULT = bl; :}
                                |
                                Identifier:id
                                {: RESULT = id; :}
                                ;

NumLiterals                 ::= NUMERO:num
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "NUMBER", num, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, Integer.toString(num));
                                :}
                                |
                                REAL:real
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "REAL", real, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, Double.toString(real));
                                :}
                                ;

StringLiterals              ::= CADENA:str
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "STRING", str, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat,"\""+str+"\"");
                                :}
                                |
                                CARACTER:ch
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "CHARACTER", ch, symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, ("'").concat(Character.toString(ch)).concat("'"));
                                :}
                                ;

BooleanLiterals             ::= TRUE
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "TRUE", new Boolean(true), symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, "true");
                                :}
                                |
                                FALSE
                                {:
                                    JavaSymbol symbol = (JavaSymbol)CUP$Parser$stack.peek();

                                    Data dat = new Data(symbol.getLexeme(), "FALSE", new Boolean(false), symbol.getLine(), symbol.getColumn());
                                    RESULT = new Node(dat, "false");
                                :}
                                ;


//------------------------------- Increment/decrement expressions -------------------------------

ExprIncDec                  ::= Identifier:id Incremento
                                {: RESULT = new Node("increase", id); :}
                                |
                                Identifier:id Decremento
                                {: RESULT = new Node("decrease", id); :};

Incremento                  ::= SUMA SUMA;

Decremento                  ::= MENOS MENOS;